/* This file is part of SilkyStrings 
 * Copyright (C) 2006  Olli Salli, Tuomas Perälä, Ville Virkkala
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

#include <WM.h>
#include <GLExtensionProxy.h>
#include <VertexDataBufferManager.h>
#include <Mesh.h>
#include <VertexFormat.h>
#include <GL.h>
#include <MeshFactory.h>

#include <cassert>
#include <vector>
#include <cmath>

#include <boost/shared_ptr.hpp>

/*
 * Test derived from the cube test, but instead of cubes spins the meshes
 * generated by MeshFactory
 */

int main()
{
  using namespace SilkyStrings;
  boost::shared_ptr<WM> wm (new WM (640, 480, false));
  boost::shared_ptr<GLExtensionProxy> proxy (new GLExtensionProxy (wm));
  boost::shared_ptr<VertexDataBufferManager> mgr (new VertexDataBufferManager (proxy));
  MeshFactory factory (mgr, proxy);
  Mesh head_mesh = factory.create_head ();
  Mesh tail_mesh = factory.create_tail ();

  while (!wm->update_beginning_of_frame ())
  {
    glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glEnable (GL_LIGHTING);
    glEnable (GL_LIGHT0);
    glEnable (GL_LIGHT1);
    glEnable (GL_DEPTH_TEST);
    glEnable (GL_CULL_FACE);

    GLfloat light0_diffuse[] = {1, 1, 1, 1};
    GLfloat light1_diffuse[] = {0.3, 0.3, 0.35, 1};

    GLfloat light0_pos[] = {0, 0, 1, 0};
    GLfloat light1_pos[] = {0, 0, 0.3, 1};

    for (int i = 0; i < 2; i++)
      light1_diffuse[i] += 0.2f * std::sin (float (wm->get_clock () + i) * 4.3f);

    glMatrixMode (GL_PROJECTION);
    glLoadIdentity ();

    gluPerspective (45, 640.0/480.0, 0.1, 100);

    glMatrixMode (GL_MODELVIEW);
    glLoadIdentity ();

    glLightfv (GL_LIGHT0, GL_DIFFUSE, light0_diffuse);
    glLightfv (GL_LIGHT1, GL_DIFFUSE, light1_diffuse);

    glLightfv (GL_LIGHT0, GL_POSITION, light0_pos);

    glTranslatef (0, 0, -8);

    glPushMatrix ();
    glRotatef (wm->get_clock () * 89, 1, 0.1, 0.12);
    glLightfv (GL_LIGHT1, GL_POSITION, light1_pos);
    glPopMatrix ();

    glRotatef (wm->get_clock () * 43, 0.2, 1, 0.2);

    glPushMatrix ();
    glTranslatef (-2, 0, 0);
    glRotatef (wm->get_clock () * 131, 0.55, 0.9, 0.13);

    head_mesh.render_indexed ();

    glPopMatrix ();
    glTranslatef (2, 0, 0);
    glRotatef (wm->get_clock () * 119, 0.8, 0.12, 0.13);

    tail_mesh.render_indexed ();

    glLoadIdentity ();
    glTranslatef (0, -5, -20);
    glRotatef (20.0f, 1, 0, 0);
    
    head_mesh.render_indexed ();

    glScalef (1, 1, 5.0f);
    tail_mesh.render_indexed ();

    wm->update_end_of_frame ();
  }

  return 0;
}

